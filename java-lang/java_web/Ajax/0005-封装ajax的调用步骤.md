获得XMLHttpRequest对象，然后向服务器发送请求，最后对服务器返回的数据进行处理。这个过程千篇一律，每次按照相同的步骤书写，故将它们封装起来是当务之急。这样的话，调用起来会方便得多。
封装的具体实现如下所示(十分经典的javascript代码，掌握并牢记)：
[code=java]
function Request(l){
	var xhr = createXhr();// 私有属性 XMLHttpRequest对象
	var listener = l; // 私有属性 此对象负责对服务端响应作反应
	// 保险起见 若初始化时没有赋予对象 则赋予一个新创建的对象
	if(!listener) listener = new ResponseListener();
	// 公有属性 请求体内容的类型 默认的表示发送的是表单数据
	// 若发送的是xml类型数据 则this.contentType = "text/xml";
	// 实际上 这个是无关痛痒的 都用默认的类型即可
	this.contentType = "application/x-www-form-urlencoded";
	// 公有方法 以GET方式发送请求
	this.doGet = function(url,async){
		sendRequest("GET", url, null, async);
	}
	// 公有方法 以POST方式发送请求
	this.doPost = function(url, requestBody, async){
		sendRequest("POST", url, requestBody, async);
	}
	// 私有方法 向服务器发送请求
	function sendRequest(method, url, requestBody, async){
		if(async == undefined) async = true; // 如果没有说明是否采用异步回调 则采用异步回调
			 // 如果async有值 并且async != ( false || 0 || null ) 则采用异步回调
				else if(async) async = true; 
			else async = false; // 其他情况( async = false || 0 || null ) 则不采用异步回调
			// 指定发送的方式、接受请求的页面(或servlet)、是否采用异步回调
			xhr.open(method, url, async);
			if(async) xhr.onreadystatechange = callback; // 指定异步回调函数
			  // 设置请求体的内容类contentType =application/x-www-form-urlencoded”
xhr.setRequestHeader("Content-Type", contentType); 
			xhr.send(requestBody); // 发送请求
			// 若没有采用异步回调 则执行此函数
			if(!async) listener.complete(
				xhr.status, xhr.statusText, xhr.responseText, xhr.responseXML
			);
	}
	// 私有函数 异步回调函数的实现
	function callback(){
		switch(xhr.readyState){
			case 0: listener.uninitialized(); break;
			case 1: listener.loading(); break;
			case 2: listener.loaded(); break;
			case 3: listener.interactive(); break;
			case 4: listener.complete(
				xhr.status, xhr.statusText, xhr.responseText, xhr.responseXML
			); break;
		}}
	// 私有函数
	function createXhr(){
		if(window.ActiveXObject){
			return new ActiveXObject("Microsoft.XMLHTTP");
		}else if(window.XMLHttpRequest){
			return new XMLHttpRequest();
		}else{
			throw new Error("Does not ajax programming");
		}}}
// 此对象处理服务端响应
function ResponseListener(){
	this.uninitialized = function(){}
	this.loading = function(){}
	this.loaded = function(){}
	this.interactive = function(){}
	// 最后一个响应状态 响应完毕
	this.complete = function(status, statusText, responseText, responseXML){}
/* 继承上面的对象 
 * 对于其它四个状态 一般是不需要处理响应的 故这里不予理会 
 * 只是覆盖响应完毕后的处理方法
 */
function ResponseAdapter(){
	this.handleText = function(text){}
	this.handleXml = function(xml){}
	this.handleError = function(status, statusText){
		alert("Error: " + status + " " + statusText);
	}
	// 覆盖父类的方法
	this.complete = function(status, statusText, responseText, responseXML){
		if(status == 200){
			this.handleText(responseText);
			this.handleXml(responseXML);
		}else{
			this.handleError(status, statusText);
		}
	}
}
// 注意 javascript的继承机制
ResponseAdapter.prototype = new ResponseListener();
ResponseAdapter.prototype.constructor = ResponseAdapter;
// 对以上部分实现功能的组织调用类
if(!kettasAjax) var kettasAjax = {};
// 采用GET方式发送请求 对返回的文本数据进行处理
if(!kettasAjax.getText){
	kettasAjax.getText = function(url, handleText, async){
		var l = new ResponseAdapter();
		l.handleText = handleText;
		var req = new Request(l);
		req.doGet(url, async);
	}}
// 采用GET方式发送请求 对返回的XML数据进行处理
if(!kettasAjax.getXml){
	kettasAjax.getXml = function(url, handleXml, async){
		var l = new ResponseAdapter();
		l.handleXml = handleXml;
		var req = new Request(l);
		req.doGet(url, async);
	}
}
// 采用POST方式发送请求 对返回的文本数据进行处理
if(!kettasAjax.postText){
	kettasAjax.postText = function(url, requestBody,handleText, async){
		var l = new ResponseAdapter();
		l.handleText = handleText;
		var req = new Request(l);
		req.doPost(url,requestBody, async);
	}
}
// 采用POST方式发送请求 对返回的XML数据进行处理
if(!kettasAjax.postXml){
	kettasAjax.postXml = function(url, requestBody, handleXml, async){
		var l = new ResponseAdapter();
		l.handleText = handleXml;
		var req = new Request(l);
		req.doPost(url, requestBody, async);
	}
}   
[/code]
注 : 以后就使用这个kettasAjax对象，会方便异常。