现在Clone已经不是一个新鲜词语了，伴随着“多莉”的产生这个词语确实很“火”过一阵子，在java中也有这么一个概念，它可以让我们很方便的“制造”出一个对象的副本来，下面来具体看看java中的Clone机制是如何工作的？
1．Clone&Copy
假设现在有一个Employee对象，通常我们会有这样的赋值Employee 
[code=java]
Employee tobby =new Employee(“CMTobby”,5000)
[/code]
cindyelf=tobby，这个时候只是简单了copy了一下reference，cindyelf和tobby都指向内存中同一个object，这样cindyelf或者tobby的一个操作都可能影响到对方。打个比方，如果我们通过cindyelf.raiseSalary()方法改变了salary域的值，那么tobby通过getSalary()方法得到的就是修改之后的salary域的值，显然这不是我们愿意看到的。我们希望得到tobby的一个精确拷贝，同时两者互不影响，这时候我们就可以使用Clone来满足我们的需求。Employee cindy=tobby.clone()，这时会生成一个新的Employee对象，并且和tobby具有相同的属性值和方法。
2．Shallow Clone&Deep Clone
Clone是如何完成的呢？Object在对某个对象实施Clone时对其是一无所知的，它仅仅是简单地执行域对域的copy，这就是Shallow Clone。这样，问题就来了咯，以Employee为例，它里面有一个域hireDay不是基本型别的变量，而是一个reference变量，经过Clone之后就会产生一个新的Date型别的reference，它和原始对象中对应的域指向同一个Date对象，这样克隆类就和原始类共享了一部分信息，而这样显然是不利的，过程下图所示：
[code=img]advance/clone.png[/code]
这个时候我们就需要进行deep Clone了，对那些非基本型别的域进行特殊的处理，例如本例中的hireDay。我们可以重新定义Clone方法，对hireDay做特殊处理，如下代码所示：
[code=java]
class Employee implements Cloneable {       
public Object clone() throws CloneNotSupportedException {
	Employee cloned = (Employee) super.clone();     
	cloned.hireDay = (Date) hireDay.clone() ;    
	return cloned;       
	}
}
[/code]
3．Clone()方法的保护机制
在Object中Clone()是被申明为protected的，这样做是有一定的道理的，以Employee类为例，通过申明为protected，就可以保证只有Employee类里面才能“克隆”Employee对象.
4．Clone()方法的使用
Clone()方法的使用比较简单，注意如下几点即可：
a．什么时候使用shallow Clone，什么时候使用deep Clone，这个主要看具体对象的域是什么性质的，基本型别还是reference variable
b．调用Clone()方法的对象所属的类(Class)必须implements Clonable接口，否则在调用Clone方法的时候会抛出CloneNotSupportedException