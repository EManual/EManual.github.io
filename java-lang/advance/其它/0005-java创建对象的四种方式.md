1 Java中创建对象的四种方式
1.1  使用用new关键字创建对象，这是最常见的创建对象的方法。
1.2  运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
1.3  调用对象的clone()方法。
1.4  运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。
2 使用用new关键字创建对象
调用类加载器加载类，并调用构造函数
3序列化
3.1应用场合
1.永久性保存对象，保存对象的字节序列到本地文件中； 
2.通过序列化对象在网络中传递对象； 
3.通过序列化在进程间传递对象。
3.2序列化条件
对象所属的类必须实现Serializable或是Externalizable接口才能被序列化。对实现了Serializable接口的类，其序列化与反序列化采用默认的序列化方式，Externalizable接口是继承了Serializable接口的接口，是对Serializable的扩展，实现了Externalizable接口的类完全自己控制序列化与反序列化行为。 
Java.io.ObjectOutputStream代表对象输出流，其方法writeObject(Object obj)可以实现对象的序列化，将得到的字节序列写到目标输出流中。Java.io.ObjectInputStream代表对象输入流，其readObject()方法能从源输入流中
读取字节序列，将其反序列化为对象，并将其返回。
3.3示例代码
[code=java]
packagpackage cn.hnpi;
  import java.io.FileInputStream;
  import java.io.FileOutputStream;
  import java.io.ObjectInputStream;
  import java.io.ObjectOutputStream;
  import java.io.Serializable;
 /**
  * Serializable接口中没有定义方法，它只用来告诉Java虚拟机它可以被序列化
 * */
public class Box implements Serializable {
/*
 * width和height的值会被保存
* **/
private int width;
private int height;
public Box() {//该构造函数在调用readObject时不会被调用
System.out.println("构造函数被调用");
}
public void setWidth(int width) {
 this.width = width;
}
public void setHeight(int height) {
 this.height = height;
}
public static void writeBoxObject(){
	 Box myBox1 = new Box();
	 myBox1.setHeight(20);
	 myBox1.setWidth(50);
	 Box myBox2 = new Box();
	 myBox2.setHeight(100);
	 myBox2.setWidth(100);
	 try {
		//1、创建FileOutputStream对象
		FileOutputStream fos=new FileOutputStream("foo.txt");//如果文件不存在就会被创建
		//2、创建ObjectOutputStream对象
		ObjectOutputStream oos=new ObjectOutputStream(fos);//把ObjectOutputStream对象与fos链接
		//3、写入对象
		oos.writeObject(myBox1);
		oos.writeObject(myBox2);
		//4、关闭ObjectOutputStream，关联的FileOutputStream也会关闭
		oos.close();
	 } catch (Exception e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	 }
}
public static void readBoxObject(){
	try {
		//1、创建FileInputStream对象
		FileInputStream fis=new FileInputStream("foo.txt");
		//2、创建ObjectInputStream对象
		ObjectInputStream ois=new ObjectInputStream(fis);
		//3、读取对象,每次调用readObject都会从stream中读取下一个对象，读取顺序与输入顺序相同，次数超过会抛出异常;不会调用读取的类的构造函数
		Object one=ois.readObject();
		Object two=ois.readObject();
		//4、转换对象类型，因为读取出来的都是Object类型，需要强制类型转换
		Box box1=(Box) one;
		System.out.println("height:"+box1.height+" width:"+box1.width);
		Box box2=(Box) two;
		System.out.println("height:"+box2.height+" width:"+box2.width);
		//5、关闭ObjectInputStream对象，FileInputStream也会跟着关闭
		ois.close();
	} catch (Exception e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
}
	public static void main(String... args) {
		writeBoxObject();
		readBoxObject();
	}
}
[/code]
4 clone
[code=java]
package cn.hnpi;
public class Person implements Cloneable {
	private String name;
	private int age;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	protected Object clone() throws CloneNotSupportedException {
		// TODO Auto-generated method stub
		return super.clone();
	}
}
 
package cn.hnpi;
public class CloneTest {
	 /**
	  * @param args
	  */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Person person=new Person();
		person.setAge(20);
		person.setName("张三");
		 
		try {
			Person clonePerson=(Person) person.clone();
			clonePerson.setName("李四");
			System.out.println("orignal person name="+person.getName());
			System.out.println("clone person name="+person.getName());
		} catch (CloneNotSupportedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}	
	}
}
[/code]
5 反射
[code=java]
package cn.hnpi;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class ReflectTest {
	// 1、通过NewInstance方法创建
	public static void createBoxObjectUsingNewInstance() {
		try {
			Box box = (Box) Class.forName("cn.hnpi.Box").newInstance();
		} catch (InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}	

	// 2、使用Constructor创建对象
	public static void createBoxObjectUsingConstructor() {
		try {
			Constructor cs = Box.class.getConstructor(null);
			Box box2 = (Box) cs.newInstance(null);
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static void main(String... args) {
		createBoxObjectUsingConstructor();
		createBoxObjectUsingNewInstance();
	}
}
[/code]