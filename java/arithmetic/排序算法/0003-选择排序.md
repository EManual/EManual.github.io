分为直接选择排序，堆排序* 直接选择排序：第i次选取 i到array.Length-1中间最小的值放在i位置。  * 堆排序：首先，数组里面用层次遍历的顺序放一棵完全二叉树。从最后一个非终端结点往前面调整，直到到达根结点，这个时候除根节点以外的所有非终端节点都已经满足堆得条件了，于是需要调整根节点使得整个树满足堆得条件，于是从根节点开始，沿着它的儿子们往下面走（最大堆沿着最大的儿子走，最小堆沿着最小的儿子走）。主程序里面，首先从最后一个非终端节点开始调整到根也调整完，形成一个heap， 然后将heap的根放到后面去（即：每次的树大小会变化，但是 root都是在1的位置，以方便计算儿子们的index，所以如果需要升序排列，则要逐步大顶堆。因为根节点被一个个放在后面去了。降序排列则要建立小顶堆）实例：初始序列：46,79,56,38,40,84建堆：  交换，从堆中踢出最大数    依次类推：最后堆中剩余的最后两个结点交换，踢出一个，排序完成。* 代码中的问题：有时候第2个和第3个顺序不对（原因还没搞明白到底代码哪里有错）选择排序Java代码：```java  public class selectSort {      public selectSort(){          int a[]={1,54,6,3,78,34,12,45};          int position=0;          for(int i=0;i<a.length;i++){              int j=i+1;              position=i;              int temp=a[i];              for(;j<a.length;j++){              if(a[j]<temp){                  temp=a[j];                  position=j;              }              }              a[position]=a[i];              a[i]=temp;          }          for(int i=0;i<a.length;i++)              System.out.println(a[i]);      }  } ```堆排序代码：```java  import java.util.Arrays;   public class HeapSort {  	int a[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};      public  HeapSort(){          heapSort(a);      }      public  void heapSort(int[] a){          System.out.println("开始排序");          int arrayLength=a.length;          //循环建堆          for(int i=0;i<arrayLength-1;i++){              //建堆        buildMaxHeap(a,arrayLength-1-i);              //交换堆顶和最后一个元素              swap(a,0,arrayLength-1-i);              System.out.println(Arrays.toString(a));          }      }       private  void swap(int[] data, int i, int j) {          // TODO Auto-generated method stub          int tmp=data[i];          data[i]=data[j];          data[j]=tmp;      }      //对data数组从0到lastIndex建大顶堆      private void buildMaxHeap(int[] data, int lastIndex) {          // TODO Auto-generated method stub          //从lastIndex处节点（最后一个节点）的父节点开始          for(int i=(lastIndex-1)/2;i>=0;i--){              //k保存正在判断的节点              int k=i;              //如果当前k节点的子节点存在              while(k*2+1<=lastIndex){                  //k节点的左子节点的索引                  int biggerIndex=2*k+1;                  //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在                  if(biggerIndex<lastIndex){                      //若果右子节点的值较大                      if(data[biggerIndex]<data[biggerIndex+1]){                          //biggerIndex总是记录较大子节点的索引                          biggerIndex++;                      }                  }                  //如果k节点的值小于其较大的子节点的值                  if(data[k]<data[biggerIndex]){                      //交换他们                      swap(data,k,biggerIndex);                      //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值                      k=biggerIndex;                  }else{                      break;                  }              }		｝	｝```