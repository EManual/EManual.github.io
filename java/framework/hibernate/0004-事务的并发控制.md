一、多个事务运行时的并发问题
并发问题归纳为以下几类：
1，第一类丢失更新：撤销一个事务时，把其他事务已经提交的更新数据覆盖。
2，赃读：一个事务读到另一个事务未提交的更新数据。
3，虚读：一个事务读到另一个事务提交的新插入的数据。
4，不可重复读：一个事务读到另一个事务已经提交的更新数据。事务A对统一数据重复读两次却得到不同的结果，有可能在A读取数据的时候事务B对统一数据做了修改。
5，第二类丢失更新：这是不可重复读中的特例，一个事务付给另一个事务已提交的更新事务。
二数据库系统提供了四种事务隔离级别供用户选择：
A.Serializable（串行化）：一个事务在执行过程中完全看不到其他事务对数据库所做的更新。
B.Repeatable Read（可重复读）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他其他事务对已有记录的更新。
C.Read Commited（读已提交数据）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新。
D.Read Uncommitted（读未提交数据）：一个事务在执行过程中可以拷打其他事务没有提交的新插入的记录，而且能看到其他事务没有提交的对已有记录的更新。
隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以有优先考虑把数据库系统的隔离级别设为Read Commited，它能够避免脏读，而且具有较好的并发性能。尽管它会导致不可重复读、虚读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制
在hibernate.cfg.xml中设置隔离级别：
```java  
<session-factory>
   <!-- 设置隔离层次，并发,缺省时Read Committed: 2 -->
   <property name="connection.isolation">2</property>
<!-- 配置事务实现类 -->
 <property name="transaction.factory_class">org.hibernate.transaction.JDBCTransactionFactory </property>
</session-factory>
```