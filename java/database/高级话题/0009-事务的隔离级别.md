由于隔离性是通过加锁的方式获得的，而锁会降低系统的性能，所以事务提供了控制隔离程度的机制。如果使用较高的隔离级别，则事务会比较好的与其他事务相隔离，当然也会带来大量的系统开销；如果使用较低的隔离级别，则事务的隔离性会比较差，但是能获得更好的性能。
事务的隔离级别分为四种：READ_UNCOMMITED、READ_COMMITED、REPEATABLE_READ、SERIALIZABLE。要理解这些隔离级别的差异必须首先弄清如下几个概念：脏读、不可重复读、幻影读取。
假设同一个A和B两个同时并发操作数据库，A和B执行的任务如下：从数据库中读取整数N，将N加上10，将新的N更新回数据库。这两个并发执行的实例可能发生下面的执行顺序。
(1)A从数据库中读取整数N，当前数据库中N=0；
(2)N 加上10，并将其更新到数据库中，当前数据库中N=10。然而由于A 的事务还没有提交，所以数据库更新还没有称为持久性的；
(3)B从数据库中读取整数N，当前数据库中N=10；
(4)A回滚了事务，所以N 恢复到了N=0；
(5)B将N 加上10，并将其更新到数据库中，当前数据库中N=20；
这里出现了B在A提交之前读取了A所更新的数据，由于A回滚了事务，所以数据库中出现了错误的数据20。尽管A回滚了事务，但是A更新的数据还是间接的通过B被更新到了数据库中。这种读取了未提交的数据的方法就叫脏(dirty)读问题。
当一个用户从数据库中读取数据的时候，另外一个用户修改了这条数据，所以数据发生了改变，当再次读取的时候就出现了不可重复读取问题。比如：
(1)A从数据库中读取整数N；
(2)B以一个新的值更新N；
(3)当A再次从数据库中读取N 的时候，会发现N 的值变了；
幻影读取指的是在两次数据库操作读取操作之间，一组新的数据会出现在数据库中。比如：
(1)A从数据库检索到了一些数据；
(2)B通过Insert语句插入了一些新数据；
(3)A再次查询的时候，新的数据就会出现；
了解了这几个概念，下面来看一下四种事务的隔离级别的区别：
1，使用READ_UNCOMMITED级别，会导致脏读问题、幻影读取问题和不可重复读取问题。在需要敏感计算任务的事务中，这样的模式是不太适合的；
2，使用READ_COMMITED级别，可以解决脏读问题，但是还会有幻影读取问题和不可重复读取问题。这种级别一般用于制作报表。这种模式是大部分系统的默认级别；
3，使用REPEATABLE_READ 级别，可以解决脏读问题和不可重复读取问题，但是会有幻影读取问题；
4，使用SERIALIZABLE 级别可以解决脏读问题、幻影读取问题和不可重复读取问题。这是最严格级别的隔离级别；