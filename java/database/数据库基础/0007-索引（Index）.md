无索引的表就是一个无序的行集。比如下面的人员表中有一些数据：
  
这个表上没有索引，因此如果我们查找年龄等于17的人员时，必须查看表中的每一行，看它是否与所需的值匹配。这是一个全表扫描，很慢，如果表中只有少数几个记录与搜索条件相匹配，则其效率是相当低的。
如果我们经常要查询某个年龄的人员，必须查看表中的每一行，看它是否与所需的值匹配。这是一个全表扫描，很慢，如果表中只有少数几个记录与搜索条件相匹配，则其效率是相当低的。
如果我们为年龄列创建一个索引，注意这里的索引所采用的值是排序的：假如我们要查找年龄为13 岁的所有人员，那么可以扫描索引，结果得出前3 行，当到达年龄为14的行的时候，我们发现它是一个比我们正在查找的年龄要大的人员。索引值是排序的，因此在读到包含14 的记录时，我们知道不会再有匹配的记录，可以退出了。如果查找一个值，它在索引表中某个中间点以前不会出现，那么也有找到其第一个匹配索引项的定位算法，而不用进行表的顺序扫描（如二分查找法）。这样，可以快速定位到第一个匹配的值，以节省大量搜索时间。
可以把索引想像成汉语字典的的按笔画查找的目录。汉语字典中的汉字是按拼音的顺序排列在书页中的，如果要查询笔画数为18 的汉字的话就必须挨个查找每个汉字来比较每个汉字的笔画数，这种速度是让人无法忍受的。而如果我们创建一个按笔画查找的目录：将笔画为5 的汉字列出来，将笔画为6 的汉字列出来……，这样当我们要查询笔画数为18 的汉字的话只要来查找这个目录就可以非常快速的查找到需要的数据了。
虽然索引可以提高数据查询的速度，但是任何事物都是双刃剑，它也有一些缺点：
索引占据一定磁盘空间，就像有按笔画查找的目录的书会比没有这种目录的书页数要多一些。
索引减慢了数据插入和删除的速度。因为每次插入和删除的时候都需要更新索引，一个表拥有的索引越多，则写操作的平均性能下降就越大。