调用该访问 返回一个以字符串指定类名的类的对象。
返回字节码，返回字节码的方式有几种:
①：这份字节码曾经被加载过已经存在java虚拟机中了直接返回。
②：java虚拟机中还没有这份字节码 用类加载器去加载 把加载进来的字节码缓存在虚拟机中，以后再得到这个字节码就不用再加载。
得到字节码对应的实例对象: 类名.class ;    对象.getClass(),例如 new Date;   类名.class，例如，System.class
对象.getClass()，例如，new Date().getClass()   Class.forName(“类名”)，例如，Class.forName(“java.util.Date”);
③：静态方法去查询或者加载这个字符串所对应哪个类的字节码。
因为在写源程序的时候还不知道类的名字，在我运行的时候人家传递我一个字符串，这个字符串里面包含了一个类的名字，再写程序的时候把java.util.Date换成一个字符串变量， 等程序运行起来的时候这个变量的值从一个配置文件里面装再进来，这个类的名字在写原程序的时候不用知道而是等运行的时候给我临时送进来。
按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，则返回代表该字节码的Class实例对象，否则，按类加载器的委托机制去搜索和加载该类，如果所有的类加载器都无法加载到该类，则抛出ClassNotFoundException。加载完这个Class字节码后，接着就可以使用Class字节码的newInstance方法去创建该类的实例对象了。
有时候，我们程序中所有使用的具体类名在设计时（即开发时）无法确定，只有程序运行时才能确定，这时候就需要使用Class.forName去动态加载该类，这个类名通常是在配置文件中配置的，例如，spring的ioc中每次依赖注入的具体类就是这样配置的，jdbc的驱动类名通常也是通过配置文件来配置的，以便在产品交付使用后不用修改源程序就可以更换驱动类名。