转型被用来将一个数值从一种类型转换到另一种类型。下面的程序连续使用了三个转型。那么它到底会打印出什么呢？
```java   
public class Multicast{
	public static void main (String[] args){
		System.out.println((int)(char)(byte) -1);
	}
}
```
无论你怎样分析这个程序，都会感到很迷惑。它以int数值-1开始，然后从int转型为byte，之后转型为char，最后转型回int。第一个转型将数值从32位窄化到了8位，第二个转型将数值从8位拓宽到了16位，最后一个转型又将数值从16位拓宽回了32位。这个数值最终是回到了起点吗？如果你运行该程序，你就会发现不是。它打印出来的是65535，但是这是为什么呢？ 
该程序的行为紧密依赖于转型的符号扩展行为。Java使用了基于2的补码的二进制运算，因此int类型的数值-1的所有32位都是置位的。从int到byte的转型是很简单的，它执行了一个窄化原始类型转化（narrowing primitive conversion），直接将除低8位之外的所有位全部砍掉。这样做留下的是一个8位都被置位了的byte，它仍旧表示-1。 
从byte到char的转型稍微麻烦一点，因为byte是一个有符号类型，而char是一个无符号类型。在将一个整数类型转换成另一个宽度更宽的整数类型时，通常是可以保持其数值的，但是却不可能将一个负的byte数值表示成一个char。因此，从byte到char的转换被认为不是一个拓宽原始类型的转换，而是一个拓宽并窄化原始类型的转换（widening and narrowing primitive conversion）：byte被转换成了int，而这个int又被转换成了char。 
所有这些听起来有点复杂，幸运的是，有一条很简单的规则能够描述从较窄的整型转换成较宽的整型时的符号扩展行为：如果最初的数值类型是有符号的，那么就执行符号扩展；如果它是char，那么不管它将要被转换成什么类型，都执行零扩展。了解这条规则可以使我们很容易地解决这个谜题。 
因为byte是一个有符号的类型，所以在将byte数值-1转换成char时，会发生符号扩展。作为结果的char数值的16个位就都被置位了，因此它等于216-1，即65535。从char到int的转型也是一个拓宽原始类型转换，所以这条规则告诉我们，它将执行零扩展而不是符号扩展。作为结果的int数值也就成了65535，这正是程序打印出的结果。 
尽管这条简单的规则描述了在有符号和无符号整型之间进行拓宽原始类型时的符号扩展行为，你最好还是不要编写出依赖于它的程序。如果你正在执行一个转型到char或从char转型的拓宽原始类型转换，并且这个char是仅有的无符号整型，那么你最好将你的意图明确地表达出来。 
如果你在将一个char数值c转型为一个宽度更宽的类型，并且你不希望有符号扩展，那么为清晰表达意图，可以考虑使用一个位掩码，即使它并不是必需的： 
```java  
int i = c & 0xffff;
```
或者，书写一句注释来描述转换的行为： 
```java  
int i = c; //不会执行符号扩展
```
如果你在将一个char数值c转型为一个宽度更宽的整型，并且你希望有符号扩展，那么就先将char转型为一个short，它与char具有同样的宽度，但是它是有符号的。在给出了这种细微的代码之后，你应该也为它书写一句注释： 
```java  
int i = (short) c; //转型将引起符号扩展
```
如果你在将一个byte数值b转型为一个char，并且你不希望有符号扩展，那么你必须使用一个位掩码来限制它。这是一种通用做法，所以不需要任何注释： 
```java  
char c = (char) (b & 0xff);
```
这个教训很简单：如果你通过观察不能确定程序将要做什么，那么它做的就很有可能不是你想要的。要为明白清晰地表达你的意图而努力。尽管有这么一条简单的规则，描述了涉及有符号和无符号整型拓宽转换的符号扩展行为，但是大多数程序员都不知道它。如果你的程序依赖于它，那么你就应该把你的意图表达清楚。