这个谜题将测试你对条件操作符的掌握程度，这个操作符有一个更广为人知的名字：问号冒号操作符。下面的程序将会打印出什么呢？ 
```java   
public class DosEquis{
	public static void main(String[] args){
		char x = ‘X’;
		int i = 0;
		System.out.println(true ? x : 0); 
		System.out.println(false ? i : x); 
	}
}
```
这个程序由两个变量声明和两个print语句构成。第一个print语句计算条件表达式(true ? x : 0)并打印出结果，这个结果是char类型变量x的值’X’。而第二个print语句计算表达式(false ? i : x)并打印出结果，这个结果还是依旧是’X’的x，因此这个程序应该打印XX。然而，如果你运行该程序，你就会发现它打印出来的是X88。这种行为看起来挺怪的。第一个print语句打印的是X，而第二个打印的却是88。它们的不同行为说明了什么呢？ 
答案就在规范有关条件表达式部分的一个阴暗的角落里。请注意在这两个表达式中，每一个表达式的第二个和第三个操作数的类型都不相同：x是char类型的，而0和i都是int类型的。就像在谜题5的解答中提到的，混合类型的计算会引起混乱，而这一点比在条件表达式中比在其它任何地方都表现得更明显。你可能考虑过，这个程序中两个条件表达式的结果类型是相同的，就像它们的操作数类型是相同的一样，尽管操作数的顺序颠倒了一下，但是实际情况并非如此。 
确定条件表达式结果类型的规则过于冗长和复杂，很难完全记住它们，但是其核心就是一下三点： 
1，如果第二个和第三个操作数具有相同的类型，那么它就是条件表达式的类型。换句话说，你可以通过绕过混合类型的计算来避免大麻烦。 
2，如果一个操作数的类型是T，T表示byte、short或char，而另一个操作数是一个int类型的常量表达式，它的值是可以用类型T表示的，那么条件表达式的类型就是T。 
3，否则，将对操作数类型运用二进制数字提升，而条件表达式的类型就是第二个和第三个操作数被提升之后的类型。
2、3两点对本谜题是关键。在程序的两个条件表达式中，一个操作数的类型是char，另一个的类型是int。在两个表达式中，int操作数都是0，它可以被表示成一个char。然而，只有第一个表达式中的int操作数是常量（0），而第二个表达式中的int操作数是变量（i）。因此，第2点被应用到了第一个表达式上，它返回的类型是char，而第3点被应用到了第二个表达式上，其返回的类型是对int和char运用了二进制数字提升之后的类型，即int。 
条件表达式的类型将确定哪一个重载的print方法将被调用。对第一个表达式来说，PrintStream.print(char)将被调用，而对第二个表达式来说，PrintStream.print(int)将被调用。前一个重载方法将变量x的值作为Unicode字符（X）来打印，而后一个重载方法将其作为一个十进制整数（88）来打印。至此，谜题被解开了。 
总之，通常最好是在条件表达式中使用类型相同的第二和第三操作数。否则，你和你的程序的读者必须要彻底理解这些表达式行为的复杂规范。 
对语言设计者来说，也许可以设计一个牺牲掉了部分灵活性，但是增加了简洁性的条件操作符。例如，要求第二和第三操作数必须就有相同的类型，这看起来就很合理。或者，条件操作符可以被定义为对常量没有任何特殊处理。为了让这些选择对程序员来说更加容易接受，可以提供用来表示所有原始类型字面常量的语法。这也许确实是一个好注意，因为它增加了语言的一致性和完备性，同时又减少了对转型的需求。