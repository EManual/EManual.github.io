下面的方法意图确定它那唯一的参数是否是一个奇数。这个方法能够正确运转吗？ 
```java  
public static boolean isOdd(int i){
	return i % 2 == 1;
}
```
奇数可以被定义为被2整除余数为1的整数。表达式 i % 2 计算的是 i 整除 2 时所产生的余数，因此看起来这个程序应该能够正确运转。遗憾的是，它不能；它在四分之一的时间里返回的都是错误的答案。 
为什么是四分之一？因为在所有的 int 数值中，有一半都是负数，而 isOdd 方法对于对所有负奇数的判断都会失败。在任何负整数上调用该方法都回返回 false ，不管该整数是偶数还是奇数。 
这是 Java 对取余操作符（%）的定义所产生的后果。该操作符被定义为对于所有的 int 数值 a 和所有的非零 int 数值 b，都满足下面的恒等式： 
```java  
(a / b) * b + (a % b) == a
```
换句话说，如果你用b整除a，将商乘以b，然后加上余数，那么你就得到了最初的值 a 。该恒等式具有正确的含义，但是当与 Java 的截尾整数整除操作符相结合时，它就意味着：当取余操作返回一个非零的结果时，它与左操作数具有相同的正负符号。 
当 i 是一个负奇数时，i % 2 等于-1而不是1， 因此 isOdd 方法将错误地返回false。为了防止这种意外，请测试你的方法在为每一个数值型参数传递负数、零和正数数值时，其行为是否正确。 
这个问题很容易订正。只需将 i % 2 与0而不是与1比较，并且反转比较的含义即可： 
```java  
public static boolean isOdd(int i){
	return i % 2 != 0;
}
```
如果你正在在一个性能临界（performance-critical）环境中使用isOdd方法，那么用位操作符AND（&）来替代取余操作符会显得更好： 
```java  
public static boolean isOdd(int i){
	return (i & 1) != 0;
}
```
总之，无论你何时使用到了取余操作符，都要考虑到操作数和结果的符号。该操作符的行为在其操作数非负时是一目了然的，但是当一个或两个操作数都是负数时，它的行为就不那么显而易见了。